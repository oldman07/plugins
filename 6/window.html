<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Model Loader with Transform Controls</title>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.1/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="buttons">
    <button id="AddWindowFrame1">Add Window 1</button>
    <button id="AddWindowFrame2">Add Window 2</button>
    <button id="addModel3">Add Window Frames</button>
    <button id="addWall">Add Wall</button>
    <button id="texture1">Apply Texture 1</button>
    <button id="texture2">Apply Texture 2</button>
   
  </div>
  
  <div class="controls">
    <h3 class=" text-white">Position</h3>
    <label class=" text-white">X: <input type="number" id="posX" step="0.1" value="0"></label><br>
    <label class="text-white">Y: <input type="number" id="posY" step="0.1" value="0"></label><br>
    <label class="text-white">Z: <input type="number" id="posZ" step="0.1" value="0"></label><br>
    <button id="applyPosition" class="btn btn-primary">Apply Position</button>
    <h3 class="text-white">Dimensions</h3>
    <label class="text-white">Length: <input type="number" id="length" step="0.1" value="1"></label><br>
    <label class="text-white">Width: <input type="number" id="width" step="0.1" value="1"></label><br>
    <label class="text-white">Height: <input type="number" id="height" step="0.1" value="1"></label><br>
    
    <button id="applyDimensions" class="btn btn-primary">Apply Dimensions</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/TextureLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js"></script>
  <script src="main.js"></script>
 
</body>
</html>





<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Model Loader with Transform Controls</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
    #buttons { position: absolute; top: 10px; left: 10px; }
    button { margin: 5px; }
    .controls { position: absolute; top: 80px; left: 10px; }
    .controls input { margin: 5px; }
  </style>
</head>
<body>
  <div id="buttons">
    <button id="addModel1">Add Model 1</button>
    <button id="addModel2">Add Model 2</button>
    <button id="addModel3">Add Model 3</button>
    <button id="texture1">Apply Texture 1</button>
    <button id="texture2">Apply Texture 2</button>
  </div>
  <div class="controls">
    <h3>Position</h3>
    <label>X: <input type="number" id="posX" step="0.1" value="0"></label><br>
    <label>Y: <input type="number" id="posY" step="0.1" value="0"></label><br>
    <label>Z: <input type="number" id="posZ" step="0.1" value="0"></label><br>
    <button id="applyPosition">Apply Position</button>
    <h3>Dimensions</h3>
    <label>Length: <input type="number" id="length" step="0.1" value="1"></label><br>
    <label>Width: <input type="number" id="width" step="0.1" value="1"></label><br>
    <label>Height: <input type="number" id="height" step="0.1" value="1"></label><br>
    <button id="applyDimensions">Apply Dimensions</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/TextureLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    let scene, camera, renderer, loader, textureLoader, controls;
    let models = [];
    let currentModel = null;
    let raycaster, mouse;

    function init() {
      // Create a scene
      scene = new THREE.Scene();
      
      // Create a camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      // Create a renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Add ambient light
      const light = new THREE.AmbientLight(0x404040);
      scene.add(light);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
      directionalLight.position.set(0, 1, 1).normalize();
      scene.add(directionalLight);

      // Initialize loaders
      loader = new THREE.GLTFLoader();
      textureLoader = new THREE.TextureLoader();

      // Initialize controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.25;
      controls.enableZoom = true;

      // Initialize raycaster and mouse
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Add event listeners for buttons
      document.getElementById('addModel1').addEventListener('click', () => loadModel('models/cube.glb', 'Model 1'));
      document.getElementById('addModel2').addEventListener('click', () => loadModel('models/sphere.glb', 'Model 2'));
      document.getElementById('addModel3').addEventListener('click', () => loadModel('models/torus.glb', 'Model 3'));
      document.getElementById('texture1').addEventListener('click', () => applyTexture('clay.jpg'));
      document.getElementById('texture2').addEventListener('click', () => applyTexture('rubber.jpg'));
      document.getElementById('applyPosition').addEventListener('click', applyPosition);
      document.getElementById('applyDimensions').addEventListener('click', applyDimensions);

      // Add event listeners for mouse interaction
      window.addEventListener('mousemove', onMouseMove, false);
      window.addEventListener('click', onClick, false);

      // Start rendering the scene
      animate();
    }

    function loadModel(modelPath, modelName) {
      loader.load(modelPath, function(gltf) {
        const model = gltf.scene;
        model.name = modelName; // Store model name for identification
        models.push(model); // Add to models list
        scene.add(model);
      }, undefined, function(error) {
        console.error(error);
      });
    }

    function applyTexture(texturePath) {
      if (currentModel) {
        textureLoader.load(texturePath, function(texture) {
          currentModel.traverse((child) => {
            if (child.isMesh) {
              child.material.map = texture;
              child.material.needsUpdate = true;
            }
          });
        }, undefined, function(error) {
          console.error(error);
        });
      } else {
        console.log('No model selected to apply texture.');
      }
    }

    function applyPosition() {
      if (currentModel) {
        const x = parseFloat(document.getElementById('posX').value);
        const y = parseFloat(document.getElementById('posY').value);
        const z = parseFloat(document.getElementById('posZ').value);

        currentModel.position.set(x, y, z);
      } else {
        console.log('No model selected to apply position.');
      }
    }

    function applyDimensions() {
      if (currentModel) {
        const length = parseFloat(document.getElementById('length').value);
        const width = parseFloat(document.getElementById('width').value);
        const height = parseFloat(document.getElementById('height').value);

        currentModel.scale.set(length, height, width);
      } else {
        console.log('No model selected to apply dimensions.');
      }
    }

    function onMouseMove(event) {
      event.preventDefault();

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
    }

    function onClick(event) {
      event.preventDefault();

      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(models, true);

      if (intersects.length > 0) {
        if (currentModel) {
          currentModel.traverse((child) => {
            if (child.isMesh) {
              child.material.emissive.set(0x000000);
            }
          });
        }

        currentModel = intersects[0].object.parent;

        currentModel.traverse((child) => {
          if (child.isMesh) {
            child.material.emissive.set(0x555555);
          }
        });
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html> -->









<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Model Loader with Transform Controls</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
    #buttons { position: absolute; top: 10px; left: 10px; }
    button { margin: 5px; }
    .controls { position: absolute; top: 80px; left: 10px; }
    .controls input { margin: 5px; }
  </style>
</head>
<body>
  <div id="buttons">
    <button id="addModel1">Add Model 1</button>
    <button id="addModel2">Add Model 2</button>
    <button id="addModel3">Add Model 3</button>
    <button id="texture1">Apply Texture 1</button>
    <button id="texture2">Apply Texture 2</button>
  </div>
  <div class="controls">
    <h3>Position</h3>
    <label>X: <input type="number" id="posX" step="0.1" value="0"></label><br>
    <label>Y: <input type="number" id="posY" step="0.1" value="0"></label><br>
    <label>Z: <input type="number" id="posZ" step="0.1" value="0"></label><br>
    <button id="applyPosition">Apply Position</button>
    <h3>Dimensions</h3>
    <label>Length: <input type="number" id="length" step="0.1" value="1"></label><br>
    <label>Width: <input type="number" id="width" step="0.1" value="1"></label><br>
    <label>Height: <input type="number" id="height" step="0.1" value="1"></label><br>
    <button id="applyDimensions">Apply Dimensions</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/TextureLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    let scene, camera, renderer, loader, textureLoader, controls;
    let models = [];
    let currentModel = null;

    function init() {
      // Create a scene
      scene = new THREE.Scene();
      
      // Create a camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      // Create a renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Add ambient light
      const light = new THREE.AmbientLight(0x404040);
      scene.add(light);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 1, 1).normalize();
      scene.add(directionalLight);

      // Initialize loaders
      loader = new THREE.GLTFLoader();
      textureLoader = new THREE.TextureLoader();

      // Initialize controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.25;
      controls.enableZoom = true;

      // Add event listeners for buttons
      document.getElementById('addModel1').addEventListener('click', () => loadModel('models/cube.glb', 'Model 1'));
      document.getElementById('addModel2').addEventListener('click', () => loadModel('models/sphere.glb', 'Model 2'));
      document.getElementById('addModel3').addEventListener('click', () => loadModel('models/torus.glb', 'Model 3'));
      document.getElementById('texture1').addEventListener('click', () => applyTexture('clay.jpg'));
      document.getElementById('texture2').addEventListener('click', () => applyTexture('rubber.jpg'));
      document.getElementById('applyPosition').addEventListener('click', applyPosition);
      document.getElementById('applyDimensions').addEventListener('click', applyDimensions);

      // Start rendering the scene
      animate();
    }

    function loadModel(modelPath, modelName) {
      loader.load(modelPath, function(gltf) {
        const model = gltf.scene;
        model.name = modelName; // Store model name for identification
        models.push(model); // Add to models list
        scene.add(model);
        currentModel = model; // Set as current model for transformations
      }, undefined, function(error) {
        console.error(error);
      });
    }

    function applyTexture(texturePath) {
      if (currentModel) {
        textureLoader.load(texturePath, function(texture) {
          currentModel.traverse((child) => {
            if (child.isMesh) {
              child.material.map = texture;
              child.material.needsUpdate = true;
            }
          });
        }, undefined, function(error) {
          console.error(error);
        });
      } else {
        console.log('No model selected to apply texture.');
      }
    }

    function applyPosition() {
      if (currentModel) {
        const x = parseFloat(document.getElementById('posX').value);
        const y = parseFloat(document.getElementById('posY').value);
        const z = parseFloat(document.getElementById('posZ').value);

        currentModel.position.set(x, y, z);
      } else {
        console.log('No model selected to apply position.');
      }
    }

    function applyDimensions() {
      if (currentModel) {
        const length = parseFloat(document.getElementById('length').value);
        const width = parseFloat(document.getElementById('width').value);
        const height = parseFloat(document.getElementById('height').value);

        currentModel.scale.set(length, height, width);
      } else {
        console.log('No model selected to apply dimensions.');
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html> -->


<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Model Loader with Transform Controls</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
    #buttons { position: absolute; top: 10px; left: 10px; }
    button { margin: 5px; }
    .controls { position: absolute; top: 80px; left: 10px; }
    .controls input { margin: 5px; }
  </style>
</head>
<body>
  <div id="buttons">
    <button id="addModel1">Add Model 1</button>
    <button id="addModel2">Add Model 2</button>
    <button id="addModel3">Add Model 3</button>
    <button id="texture1">Apply Texture 1</button>
    <button id="texture2">Apply Texture 2</button>
  </div>
  <div class="controls">
    <label>X: <input type="number" id="posX" step="0.1" value="0"></label><br>
    <label>Y: <input type="number" id="posY" step="0.1" value="0"></label><br>
    <label>Z: <input type="number" id="posZ" step="0.1" value="0"></label><br>
    <button id="applyPosition">Apply Position</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/TextureLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    let scene, camera, renderer, loader, textureLoader, controls;
    let models = [];
    let currentModel = null;

    function init() {
      // Create a scene
      scene = new THREE.Scene();
      
      // Create a camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      // Create a renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Add ambient light
      const light = new THREE.AmbientLight(0x404040);
      scene.add(light);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 1, 1).normalize();
      scene.add(directionalLight);

      // Initialize loaders
      loader = new THREE.GLTFLoader();
      textureLoader = new THREE.TextureLoader();

      // Initialize controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.25;
      controls.enableZoom = true;

      // Add event listeners for buttons
      document.getElementById('addModel1').addEventListener('click', () => loadModel('models/cube.glb', 'Model 1'));
      document.getElementById('addModel2').addEventListener('click', () => loadModel('models/sphere.glb', 'Model 2'));
      document.getElementById('addModel3').addEventListener('click', () => loadModel('models/torus.glb', 'Model 3'));
      document.getElementById('texture1').addEventListener('click', () => applyTexture('clay.jpg'));
      document.getElementById('texture2').addEventListener('click', () => applyTexture('rubber.jpg'));
      document.getElementById('applyPosition').addEventListener('click', applyPosition);

      // Start rendering the scene
      animate();
    }

    function loadModel(modelPath, modelName) {
      loader.load(modelPath, function(gltf) {
        const model = gltf.scene;
        model.name = modelName; // Store model name for identification
        models.push(model); // Add to models list
        scene.add(model);
        currentModel = model; // Set as current model for transformations
      }, undefined, function(error) {
        console.error(error);
      });
    }

    function applyTexture(texturePath) {
      if (currentModel) {
        textureLoader.load(texturePath, function(texture) {
          currentModel.traverse((child) => {
            if (child.isMesh) {
              child.material.map = texture;
              child.material.needsUpdate = true;
            }
          });
        }, undefined, function(error) {
          console.error(error);
        });
      } else {
        console.log('No model selected to apply texture.');
      }
    }

    function applyPosition() {
      if (currentModel) {
        const x = parseFloat(document.getElementById('posX').value);
        const y = parseFloat(document.getElementById('posY').value);
        const z = parseFloat(document.getElementById('posZ').value);

        currentModel.position.set(x, y, z);
      } else {
        console.log('No model selected to apply position.');
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html> -->




<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Model Loader with Textures</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
    #buttons { position: absolute; top: 10px; left: 10px; }
    button { margin: 5px; }
    .controls { position: absolute; top: 80px; left: 10px; }
    .controls input { margin: 5px; }
  </style>
</head>
<body>
  <div id="buttons">
    <button id="addModel1">Add Model 1</button>
    <button id="addModel2">Add Model 2</button>
    <button id="addModel3">Add Model 3</button>
    <button id="texture1">Apply Texture 1</button>
    <button id="texture2">Apply Texture 2</button>
  </div>
  <div class="controls">
    <label>Length: <input type="number" id="length" step="0.1" value="1"></label><br>
    <label>Width: <input type="number" id="width" step="0.1" value="1"></label><br>
    <label>Height: <input type="number" id="height" step="0.1" value="1"></label><br>
    <button id="applyDimensions">Apply Dimensions</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/TextureLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    let scene, camera, renderer, loader, textureLoader, controls;
    let models = [];
    let raycaster, mouse;
    let intersectedObject = null;

    function init() {
      // Create a scene
      scene = new THREE.Scene();
      
      // Create a camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      // Create a renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Add ambient light
      const light = new THREE.AmbientLight(0x404040);
      scene.add(light);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 1, 1).normalize();
      scene.add(directionalLight);

      // Initialize loaders
      loader = new THREE.GLTFLoader();
      textureLoader = new THREE.TextureLoader();

      // Initialize controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.25;
      controls.enableZoom = true;

      // Initialize raycaster and mouse
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Add event listeners for buttons
      document.getElementById('addModel1').addEventListener('click', () => loadModel('models/cube.glb', 'Model 1'));
      document.getElementById('addModel2').addEventListener('click', () => loadModel('models/sphere.glb', 'Model 2'));
      document.getElementById('addModel3').addEventListener('click', () => loadModel('models/torus.glb', 'Model 3'));
      document.getElementById('texture1').addEventListener('click', () => applyTexture('clay.jpg'));
      document.getElementById('texture2').addEventListener('click', () => applyTexture('rubber.jpg'));
      document.getElementById('applyDimensions').addEventListener('click', applyDimensions);

      // Add event listeners for mouse interaction
      window.addEventListener('mousemove', onMouseMove, false);

      // Start rendering the scene
      animate();
    }

    function loadModel(modelPath, modelName) {
      loader.load(modelPath, function(gltf) {
        const model = gltf.scene;
        model.name = modelName; // Store model name for identification
        models.push(model); // Add to models list
        scene.add(model);
      }, undefined, function(error) {
        console.error(error);
      });
    }

    function applyTexture(texturePath) {
      if (models.length > 0) {
        textureLoader.load(texturePath, function(texture) {
          models.forEach((model) => {
            model.traverse((child) => {
              if (child.isMesh) {
                child.material.map = texture;
                child.material.needsUpdate = true;
              }
            });
          });
        }, undefined, function(error) {
          console.error(error);
        });
      } else {
        console.log('No models loaded to apply texture.');
      }
    }

    function applyDimensions() {
      if (models.length > 0) {
        const length = parseFloat(document.getElementById('length').value);
        const width = parseFloat(document.getElementById('width').value);
        const height = parseFloat(document.getElementById('height').value);

        models.forEach((model) => {
          model.traverse((child) => {
            if (child.isMesh) {
              child.scale.set(length, height, width);
            }
          });
        });
      } else {
        console.log('No models loaded to apply dimensions.');
      }
    }

    function onMouseMove(event) {
      event.preventDefault();

      // Update the mouse variable with the position of the mouse
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

      // Update the raycaster
      raycaster.setFromCamera(mouse, camera);

      if (models.length > 0) {
        // Check for intersections with all models
        let intersects = [];
        models.forEach((model) => {
          intersects = intersects.concat(raycaster.intersectObject(model, true));
        });

        if (intersects.length > 0) {
          intersectedObject = intersects[0].object;
          console.log('Selected Model:', intersectedObject.parent.name); // Log the name of the model
          splitModel(intersectedObject);
        }
      }
    }

    function splitModel(object) {
      if (!object) return;

      // Function to split a mesh into two parts
      function splitGeometry(geometry, axis, position) {
        const vertices = geometry.attributes.position.array;
        const indices = geometry.index.array;
        const newGeometry1 = new THREE.BufferGeometry();
        const newGeometry2 = new THREE.BufferGeometry();
        const vertices1 = [];
        const vertices2 = [];
        const indices1 = [];
        const indices2 = [];
        const vertexMap1 = new Map();
        const vertexMap2 = new Map();

        for (let i = 0; i < vertices.length; i += 3) {
          const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
          if (vertex[axis] < position) {
            vertices1.push(vertices[i], vertices[i + 1], vertices[i + 2]);
            vertexMap1.set(`${vertices[i]}-${vertices[i + 1]}-${vertices[i + 2]}`, vertices1.length / 3 - 1);
          } else {
            vertices2.push(vertices[i], vertices[i + 1], vertices[i + 2]);
            vertexMap2.set(`${vertices[i]}-${vertices[i + 1]}-${vertices[i + 2]}`, vertices2.length / 3 - 1);
          }
        }

        for (let i = 0; i < indices.length; i += 3) {
          const idx1 = vertexMap1.get(`${vertices[indices[i] * 3]}-${vertices[indices[i] * 3 + 1]}-${vertices[indices[i] * 3 + 2]}`);
          const idx2 = vertexMap1.get(`${vertices[indices[i + 1] * 3]}-${vertices[indices[i + 1] * 3 + 1]}-${vertices[indices[i + 1] * 3 + 2]}`);
          const idx3 = vertexMap1.get(`${vertices[indices[i + 2] * 3]}-${vertices[indices[i + 2] * 3 + 1]}-${vertices[indices[i + 2] * 3 + 2]}`);
          if (idx1 !== undefined && idx2 !== undefined && idx3 !== undefined) {
            indices1.push(idx1, idx2, idx3);
          }

          const idx4 = vertexMap2.get(`${vertices[indices[i] * 3]}-${vertices[indices[i] * 3 + 1]}-${vertices[indices[i] * 3 + 2]}`);
          const idx5 = vertexMap2.get(`${vertices[indices[i + 1] * 3]}-${vertices[indices[i + 1] * 3 + 1]}-${vertices[indices[i + 1] * 3 + 2]}`);
          const idx6 = vertexMap2.get(`${vertices[indices[i + 2] * 3]}-${vertices[indices[i + 2] * 3 + 1]}-${vertices[indices[i + 2] * 3 + 2]}`);
          if (idx4 !== undefined && idx5 !== undefined && idx6 !== undefined) {
            indices2.push(idx4, idx5, idx6);
          }
        }

        newGeometry1.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices1), 3));
        newGeometry1.setIndex(new THREE.BufferAttribute(new Uint16Array(indices1), 1));
        newGeometry2.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices2), 3));
        newGeometry2.setIndex(new THREE.BufferAttribute(new Uint16Array(indices2), 1));

        return [newGeometry1, newGeometry2];
      }

      // Split the object into two parts
      if (object.isMesh) {
        const geometry = object.geometry;
        const [geometry1, geometry2] = splitGeometry(geometry, 'x', object.position.x);

        // Create two new meshes with the split geometries
        const material = object.material;
        const mesh1 = new THREE.Mesh(geometry1, material);
        const mesh2 = new THREE.Mesh(geometry2, material);

        // Position the new meshes
        mesh1.position.copy(object.position);
        mesh2.position.copy(object.position);

        scene.remove(object);
        scene.add(mesh1);
        scene.add(mesh2);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html>
 -->



<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Model Loader with Textures</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
    #buttons { position: absolute; top: 10px; left: 10px; }
    button { margin: 5px; }
    .controls { position: absolute; top: 80px; left: 10px; }
    .controls input { margin: 5px; }
  </style>
</head>
<body>
  <div id="buttons">
    <button id="addModel1">Add Model 1</button>
    <button id="addModel2">Add Model 2</button>
    <button id="addModel3">Add Model 3</button>
    <button id="texture1">Apply Texture 1</button>
    <button id="texture2">Apply Texture 2</button>
  </div>
  <div class="controls">
    <label>Length: <input type="number" id="length" step="0.1" value="1"></label><br>
    <label>Width: <input type="number" id="width" step="0.1" value="1"></label><br>
    <label>Height: <input type="number" id="height" step="0.1" value="1"></label><br>
    <button id="applyDimensions">Apply Dimensions</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/TextureLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    let scene, camera, renderer, loader, textureLoader, controls;
    let models = [];
    let raycaster, mouse;
    let intersectedObject = null;

    function init() {
      // Create a scene
      scene = new THREE.Scene();
      
      // Create a camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      // Create a renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Add ambient light
      const light = new THREE.AmbientLight(0x404040);
      scene.add(light);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 1, 1).normalize();
      scene.add(directionalLight);

      // Initialize loaders
      loader = new THREE.GLTFLoader();
      textureLoader = new THREE.TextureLoader();

      // Initialize controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.25;
      controls.enableZoom = true;

      // Initialize raycaster and mouse
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Add event listeners for buttons
      document.getElementById('addModel1').addEventListener('click', () => loadModel('models/cube.glb', 'Model 1'));
      document.getElementById('addModel2').addEventListener('click', () => loadModel('models/sphere.glb', 'Model 2'));
      document.getElementById('addModel3').addEventListener('click', () => loadModel('models/torus.glb', 'Model 3'));
      document.getElementById('texture1').addEventListener('click', () => applyTexture('clay.jpg'));
      document.getElementById('texture2').addEventListener('click', () => applyTexture('rubber.jpg'));
      document.getElementById('applyDimensions').addEventListener('click', applyDimensions);

      // Add event listeners for mouse interaction
      window.addEventListener('mousemove', onMouseMove, false);

      // Start rendering the scene
      animate();
    }

    function loadModel(modelPath, modelName) {
      loader.load(modelPath, function(gltf) {
        const model = gltf.scene;
        model.name = modelName; // Store model name for identification
        models.push(model); // Add to models list
        scene.add(model);
      }, undefined, function(error) {
        console.error(error);
      });
    }

    function applyTexture(texturePath) {
      if (models.length > 0) {
        textureLoader.load(texturePath, function(texture) {
          models.forEach((model) => {
            model.traverse((child) => {
              if (child.isMesh) {
                child.material.map = texture;
                child.material.needsUpdate = true;
              }
            });
          });
        }, undefined, function(error) {
          console.error(error);
        });
      } else {
        console.log('No models loaded to apply texture.');
      }
    }

    function applyDimensions() {
      if (models.length > 0) {
        const length = parseFloat(document.getElementById('length').value);
        const width = parseFloat(document.getElementById('width').value);
        const height = parseFloat(document.getElementById('height').value);

        models.forEach((model) => {
          model.traverse((child) => {
            if (child.isMesh) {
              child.scale.set(length, height, width);
            }
          });
        });
      } else {
        console.log('No models loaded to apply dimensions.');
      }
    }

    function onMouseMove(event) {
      event.preventDefault();

      // Update the mouse variable with the position of the mouse
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

      // Update the raycaster
      raycaster.setFromCamera(mouse, camera);

      if (models.length > 0) {
        // Check for intersections with all models
        let intersects = [];
        models.forEach((model) => {
          intersects = intersects.concat(raycaster.intersectObject(model, true));
        });

        if (intersects.length > 0) {
          intersectedObject = intersects[0].object;
          console.log('Selected Model:', intersectedObject.parent.name); // Log the name of the model
          splitModel(intersectedObject);
        }
      }
    }

    function splitModel(object) {
      if (!object) return;

      // Function to split a mesh into two parts
      function splitGeometry(geometry, axis, position) {
        const vertices = geometry.attributes.position.array;
        const indices = geometry.index.array;
        const newGeometry1 = new THREE.BufferGeometry();
        const newGeometry2 = new THREE.BufferGeometry();
        const vertices1 = [];
        const vertices2 = [];
        const indices1 = [];
        const indices2 = [];
        const vertexMap1 = new Map();
        const vertexMap2 = new Map();

        for (let i = 0; i < vertices.length; i += 3) {
          const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
          if (vertex[axis] < position) {
            vertices1.push(vertices[i], vertices[i + 1], vertices[i + 2]);
            vertexMap1.set(`${vertices[i]}-${vertices[i + 1]}-${vertices[i + 2]}`, vertices1.length / 3 - 1);
          } else {
            vertices2.push(vertices[i], vertices[i + 1], vertices[i + 2]);
            vertexMap2.set(`${vertices[i]}-${vertices[i + 1]}-${vertices[i + 2]}`, vertices2.length / 3 - 1);
          }
        }

        for (let i = 0; i < indices.length; i += 3) {
          const idx1 = vertexMap1.get(`${vertices[indices[i] * 3]}-${vertices[indices[i] * 3 + 1]}-${vertices[indices[i] * 3 + 2]}`);
          const idx2 = vertexMap1.get(`${vertices[indices[i + 1] * 3]}-${vertices[indices[i + 1] * 3 + 1]}-${vertices[indices[i + 1] * 3 + 2]}`);
          const idx3 = vertexMap1.get(`${vertices[indices[i + 2] * 3]}-${vertices[indices[i + 2] * 3 + 1]}-${vertices[indices[i + 2] * 3 + 2]}`);
          if (idx1 !== undefined && idx2 !== undefined && idx3 !== undefined) {
            indices1.push(idx1, idx2, idx3);
          }

          const idx4 = vertexMap2.get(`${vertices[indices[i] * 3]}-${vertices[indices[i] * 3 + 1]}-${vertices[indices[i] * 3 + 2]}`);
          const idx5 = vertexMap2.get(`${vertices[indices[i + 1] * 3]}-${vertices[indices[i + 1] * 3 + 1]}-${vertices[indices[i + 1] * 3 + 2]}`);
          const idx6 = vertexMap2.get(`${vertices[indices[i + 2] * 3]}-${vertices[indices[i + 2] * 3 + 1]}-${vertices[indices[i + 2] * 3 + 2]}`);
          if (idx4 !== undefined && idx5 !== undefined && idx6 !== undefined) {
            indices2.push(idx4, idx5, idx6);
          }
        }

        newGeometry1.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices1), 3));
        newGeometry1.setIndex(new THREE.BufferAttribute(new Uint16Array(indices1), 1));
        newGeometry2.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices2), 3));
        newGeometry2.setIndex(new THREE.BufferAttribute(new Uint16Array(indices2), 1));

        return [newGeometry1, newGeometry2];
      }

      // Split the object into two parts
      if (object.isMesh) {
        const geometry = object.geometry;
        const [geometry1, geometry2] = splitGeometry(geometry, 'x', object.position.x);

        // Create two new meshes with the split geometries
        const material = object.material;
        const mesh1 = new THREE.Mesh(geometry1, material);
        const mesh2 = new THREE.Mesh(geometry2, material);

        // Position the new meshes
        mesh1.position.copy(object.position);
        mesh2.position.copy(object.position);

        scene.remove(object);
        scene.add(mesh1);
        scene.add(mesh2);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html>
 -->


<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Model Loader with Textures</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
    #buttons { position: absolute; top: 10px; left: 10px; }
    button { margin: 5px; }
    .controls { position: absolute; top: 80px; left: 10px; }
    .controls input { margin: 5px; }
  </style>
</head>
<body>
  <div id="buttons">
    <button id="addModel1">Add Model 1</button>
    <button id="addModel2">Add Model 2</button>
    <button id="addModel3">Add Model 3</button>
    <button id="texture1">Apply Texture 1</button>
    <button id="texture2">Apply Texture 2</button>
  </div>
  <div class="controls">
    <label>Length: <input type="number" id="length" step="0.1" value="1"></label><br>
    <label>Width: <input type="number" id="width" step="0.1" value="1"></label><br>
    <label>Height: <input type="number" id="height" step="0.1" value="1"></label><br>
    <button id="applyDimensions">Apply Dimensions</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/TextureLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    let scene, camera, renderer, loader, textureLoader, controls;
    let currentModel = null;
    let raycaster, mouse;
    let intersectedObject = null;

    function init() {
      // Create a scene
      scene = new THREE.Scene();
      
      // Create a camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      // Create a renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      
      // Add ambient light
      const light = new THREE.AmbientLight(0x404040);
      scene.add(light);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 1, 1).normalize();
      scene.add(directionalLight);

      // Initialize loaders
      loader = new THREE.GLTFLoader();
      textureLoader = new THREE.TextureLoader();

      // Initialize controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.25;
      controls.enableZoom = true;

      // Initialize raycaster and mouse
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      // Add event listeners for buttons
      document.getElementById('addModel1').addEventListener('click', () => loadModel('models/cube.glb'));
      document.getElementById('addModel2').addEventListener('click', () => loadModel('models/sphere.glb'));
      document.getElementById('addModel3').addEventListener('click', () => loadModel('models/torus.glb'));
      document.getElementById('texture1').addEventListener('click', () => applyTexture('clay.jpg'));
      document.getElementById('texture2').addEventListener('click', () => applyTexture('rubber.jpg'));
      document.getElementById('applyDimensions').addEventListener('click', applyDimensions);

      // Add event listeners for mouse interaction
      window.addEventListener('mousemove', onMouseMove, false);

      // Start rendering the scene
      animate();
    }

    function loadModel(modelPath) {
      loader.load(modelPath, function(gltf) {
        // Remove the previous model if it exists
        if (currentModel) {
          scene.remove(currentModel);
        }

        // Add the new model
        currentModel = gltf.scene;
        scene.add(currentModel);
      }, undefined, function(error) {
        console.error(error);
      });
    }

    function applyTexture(texturePath) {
      if (currentModel) {
        textureLoader.load(texturePath, function(texture) {
          currentModel.traverse((child) => {
            if (child.isMesh) {
              child.material.map = texture;
              child.material.needsUpdate = true;
            }
          });
        }, undefined, function(error) {
          console.error(error);
        });
      } else {
        console.log('No model loaded to apply texture.');
      }
    }

    function applyDimensions() {
      if (currentModel) {
        const length = parseFloat(document.getElementById('length').value);
        const width = parseFloat(document.getElementById('width').value);
        const height = parseFloat(document.getElementById('height').value);
        
        currentModel.traverse((child) => {
          if (child.isMesh) {
            child.scale.set(length, height, width);
          }
        });
      } else {
        console.log('No model loaded to apply dimensions.');
      }
    }

    function onMouseMove(event) {
      event.preventDefault();

      // Update the mouse variable with the position of the mouse
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

      // Update the raycaster
      raycaster.updateMatrixWorld();
      raycaster.setFromCamera(mouse, camera);

      if (currentModel) {
        // Check for intersections with the model
        const intersects = raycaster.intersectObject(currentModel, true);

        if (intersects.length > 0) {
          intersectedObject = intersects[0].object;
          splitModel(intersectedObject);
        }
      }
    }

    function splitModel(object) {
      if (!object) return;

      // Function to split a mesh into two parts
      function splitGeometry(geometry, axis, position) {
        const vertices = geometry.attributes.position.array;
        const indices = geometry.index.array;
        const newGeometry1 = new THREE.BufferGeometry();
        const newGeometry2 = new THREE.BufferGeometry();
        const vertices1 = [];
        const vertices2 = [];
        const indices1 = [];
        const indices2 = [];
        const vertexMap1 = new Map();
        const vertexMap2 = new Map();

        for (let i = 0; i < vertices.length; i += 3) {
          const vertex = new THREE.Vector3(vertices[i], vertices[i + 1], vertices[i + 2]);
          if (vertex[axis] < position) {
            vertices1.push(vertices[i], vertices[i + 1], vertices[i + 2]);
            vertexMap1.set(`${vertices[i]}-${vertices[i + 1]}-${vertices[i + 2]}`, vertices1.length / 3 - 1);
          } else {
            vertices2.push(vertices[i], vertices[i + 1], vertices[i + 2]);
            vertexMap2.set(`${vertices[i]}-${vertices[i + 1]}-${vertices[i + 2]}`, vertices2.length / 3 - 1);
          }
        }

        for (let i = 0; i < indices.length; i += 3) {
          const idx1 = vertexMap1.get(`${vertices[indices[i] * 3]}-${vertices[indices[i] * 3 + 1]}-${vertices[indices[i] * 3 + 2]}`);
          const idx2 = vertexMap1.get(`${vertices[indices[i + 1] * 3]}-${vertices[indices[i + 1] * 3 + 1]}-${vertices[indices[i + 1] * 3 + 2]}`);
          const idx3 = vertexMap1.get(`${vertices[indices[i + 2] * 3]}-${vertices[indices[i + 2] * 3 + 1]}-${vertices[indices[i + 2] * 3 + 2]}`);
          if (idx1 !== undefined && idx2 !== undefined && idx3 !== undefined) {
            indices1.push(idx1, idx2, idx3);
          }

          const idx4 = vertexMap2.get(`${vertices[indices[i] * 3]}-${vertices[indices[i] * 3 + 1]}-${vertices[indices[i] * 3 + 2]}`);
          const idx5 = vertexMap2.get(`${vertices[indices[i + 1] * 3]}-${vertices[indices[i + 1] * 3 + 1]}-${vertices[indices[i + 1] * 3 + 2]}`);
          const idx6 = vertexMap2.get(`${vertices[indices[i + 2] * 3]}-${vertices[indices[i + 2] * 3 + 1]}-${vertices[indices[i + 2] * 3 + 2]}`);
          if (idx4 !== undefined && idx5 !== undefined && idx6 !== undefined) {
            indices2.push(idx4, idx5, idx6);
          }
        }

        newGeometry1.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices1), 3));
        newGeometry1.setIndex(new THREE.BufferAttribute(new Uint16Array(indices1), 1));
        newGeometry2.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices2), 3));
        newGeometry2.setIndex(new THREE.BufferAttribute(new Uint16Array(indices2), 1));

        return [newGeometry1, newGeometry2];
      }

      // Split the object into two parts
      if (object.isMesh) {
        const geometry = object.geometry;
        const [geometry1, geometry2] = splitGeometry(geometry, 'x', object.position.x);

        // Create two new meshes with the split geometries
        const material = object.material;
        const mesh1 = new THREE.Mesh(geometry1, material);
        const mesh2 = new THREE.Mesh(geometry2, material);

        // Position the new meshes
        mesh1.position.copy(object.position);
        mesh2.position.copy(object.position);

        scene.remove(object);
        scene.add(mesh1);
        scene.add(mesh2);
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true
      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html>
 -->

